---
phase: 01-engine-systems
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - index.html
  - css/styles.css
  - js/game.js
  - js/scene.js
  - js/cursor.js
autonomous: true

must_haves:
  truths:
    - "Player sees a full-screen scene with colored placeholder background and hotspot regions"
    - "Cursor changes appearance (look, use, talk) when hovering over different hotspot types"
    - "Clicking an exit hotspot fades out the current scene and fades in the destination scene"
    - "Two test scenes exist and the player can navigate between them via exit hotspots"
  artifacts:
    - path: "index.html"
      provides: "Game shell with all script/link tags, scene container, inventory bar placeholder, dialogue container placeholder"
      contains: "id=\"scene-container\""
    - path: "js/game.js"
      provides: "Central game state (currentScene, inventory array, gameFlags object), scene registration, scene switching"
      contains: "GameState"
    - path: "js/scene.js"
      provides: "Scene rendering, hotspot creation from data, hotspot click dispatch"
      contains: "renderScene"
    - path: "js/cursor.js"
      provides: "Cursor mode switching on hotspot hover (look, use, talk, exit)"
      contains: "setCursorMode"
    - path: "css/styles.css"
      provides: "Full-screen layout, hotspot styling, cursor classes, fade transition"
      contains: "cursor"
  key_links:
    - from: "js/scene.js"
      to: "js/game.js"
      via: "renderScene reads scene data from GameState"
      pattern: "gameState\\.(scenes|currentScene)"
    - from: "js/cursor.js"
      to: "js/scene.js"
      via: "hotspot mouseenter/mouseleave events trigger cursor mode changes"
      pattern: "setCursorMode"
    - from: "js/scene.js"
      to: "css/styles.css"
      via: "fade-out/fade-in CSS classes applied during scene transition"
      pattern: "fade"
---

<objective>
Build the scene engine foundation: game shell, state manager, scene rendering with hotspots, cursor mode switching, and smooth room-to-room transitions.

Purpose: This is the container everything else plugs into. Inventory and dialogue systems both render inside scenes and respond to hotspot clicks, so the scene engine must exist first.
Output: A playable two-room demo where the player can click exits to move between scenes, see hotspots, and watch the cursor change.
</objective>

<execution_context>
@/Users/brent/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brent/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Game shell and state manager</name>
  <files>index.html, css/styles.css, js/game.js</files>
  <action>
Create the full game shell that all three Phase 1 plans will use:

**index.html:**
- Standard HTML5 document with viewport meta tag
- Link tags for: css/styles.css, css/inventory.css, css/dialogue.css (inventory and dialogue CSS files will be created by later plans -- include the links now so those plans don't need to touch index.html)
- A div#game-container that fills the viewport
  - div#scene-container (full-screen, holds scene background and hotspots)
  - div#inventory-bar (fixed bottom bar, initially empty -- Plan 02 will populate)
  - div#dialogue-container (overlay, initially hidden -- Plan 03 will populate)
  - div#text-display (for examine/action text feedback, positioned bottom-center above inventory bar)
- Script tags for: js/game.js, js/scene.js, js/cursor.js, js/inventory.js, js/dialogue.js (inventory.js and dialogue.js created by later plans)
- A single DOMContentLoaded listener in a small inline script that calls Game.init()

**js/game.js:**
- GameState object (module pattern or plain object on window.Game) with:
  - currentScene: string (scene ID)
  - inventory: array of item objects {id, name, description, icon}
  - flags: object for game state flags (e.g., {ticketMachineFixed: false})
  - scenes: registry object mapping scene IDs to scene data
- Game.init() -- registers scenes, renders the starting scene
- Game.changeScene(sceneId) -- triggers transition, then renders new scene
- Game.addItem(item) / Game.removeItem(itemId) / Game.hasItem(itemId) -- inventory helpers (Plans 02 will hook into these)
- Game.setFlag(key, value) / Game.getFlag(key) -- state flag helpers
- Game.showText(text) -- displays text in #text-display for 3 seconds, then fades out
- Register two test scenes for verification: "test-room-a" and "test-room-b", each with a colored background, a couple of hotspots (one exit to the other room, one "look" type, one "talk" type), defined as plain data objects

Scene data shape:
```
{
  id: "test-room-a",
  name: "Test Room A",
  background: "#2a3a4a",  // placeholder color, will be image URL later
  hotspots: [
    { id: "exit-to-b", type: "exit", x: 80, y: 40, width: 15, height: 50, target: "test-room-b", label: "Door to Room B" },
    { id: "poster", type: "look", x: 10, y: 20, width: 12, height: 15, label: "Faded poster", onInteract: "A motivational poster reads: 'Hang in there!'" },
    { id: "npc-bob", type: "talk", x: 40, y: 30, width: 10, height: 40, label: "Bob", dialogueId: "bob-intro" }
  ]
}
```

**css/styles.css:**
- Reset box-sizing, margin, padding on *, html, body
- html, body: 100% width/height, overflow hidden, background black, font-family sans-serif
- #game-container: relative, 100vw x 100vh
- #scene-container: absolute, fills game-container, transition: opacity 0.4s
- .scene-background: fills scene-container (will use background-image later, background-color for now)
- #inventory-bar: fixed bottom, 64px height, dark background, flex row, z-index 10
- #dialogue-container: absolute overlay, hidden by default, z-index 20
- #text-display: fixed bottom 80px, centered, white text on semi-transparent dark bg, opacity transition, pointer-events none, z-index 15
- .hotspot: absolute, cursor pointer, border 2px dashed rgba(255,255,255,0.3) for debug visibility (will be transparent in production), transition border-color
- .hotspot:hover -- brighter border for debug
- Cursor classes: .cursor-default, .cursor-look, .cursor-use, .cursor-talk, .cursor-exit -- each sets a different cursor (use CSS cursor property with built-in cursors for now: default, help, pointer, crosshair, e-resize; Phase 4 will replace with custom icons)
- .scene-fade-out: opacity 0
- .scene-fade-in: opacity 1

Do NOT use ES modules (import/export) -- the project uses vanilla script tags. Attach to window or use a global namespace pattern (window.Game = {...}).
  </action>
  <verify>Open index.html in a browser. The page should show a colored background filling the viewport with dashed hotspot outlines visible. No console errors.</verify>
  <done>index.html loads without errors, displays test-room-a background color, and shows hotspot outlines. Game state object is accessible in console as Game or window.Game.</done>
</task>

<task type="auto">
  <name>Task 2: Hotspot interaction, cursor modes, and scene transitions</name>
  <files>js/scene.js, js/cursor.js</files>
  <action>
**js/scene.js:**
- Scene.render(sceneId) function:
  - Clears #scene-container children
  - Looks up scene data from Game.scenes[sceneId]
  - Creates a div.scene-background with background-color (later background-image) from scene data
  - For each hotspot in scene data, creates a div.hotspot absolutely positioned using hotspot.x, hotspot.y, hotspot.width, hotspot.height (all as percentages of scene-container -- this ensures hotspots work regardless of window size)
  - Each hotspot div stores its data as data-attributes or a JS reference (e.g., element._hotspotData = hotspot)
  - Attaches mouseenter/mouseleave for cursor changes (calls Cursor.setMode)
  - Attaches click handler that dispatches by hotspot type:
    - "exit": calls Game.changeScene(hotspot.target)
    - "look": calls Game.showText(hotspot.onInteract)
    - "talk": calls Dialogue.open(hotspot.dialogueId) if Dialogue exists, otherwise Game.showText("(Dialogue system not yet available)")
    - "pickup": calls Inventory.pickUp(hotspot) if Inventory exists, otherwise Game.showText("(Inventory system not yet available)")
    - "use": checks if player has selected inventory item, then triggers use logic (deferred to Plan 02)
  - The dispatch gracefully handles missing systems (check `typeof Dialogue !== 'undefined'` etc.) so the scene engine works standalone before Plans 02/03 run

- Wire Game.changeScene(sceneId) to:
  1. Add class "scene-fade-out" to #scene-container
  2. After CSS transition completes (use transitionend event or 400ms setTimeout), call Scene.render(newSceneId)
  3. Remove "scene-fade-out" class to fade back in
  4. Update Game.currentScene

**js/cursor.js:**
- Cursor object with:
  - Cursor.setMode(mode) -- removes all cursor-* classes from #game-container, adds cursor-{mode}
  - Cursor.reset() -- sets mode to "default"
- Hotspot type to cursor mode mapping:
  - "look" -> "look"
  - "exit" -> "exit"
  - "talk" -> "talk"
  - "pickup" -> "use"
  - "use" -> "use"
- On mouseenter of hotspot: Cursor.setMode based on hotspot type
- On mouseleave of hotspot: Cursor.reset()

Make sure Game.init() calls Scene.render(Game.currentScene) at the end so the first scene appears on load.

Do NOT use ES modules. Attach to window (window.Scene, window.Cursor).
  </action>
  <verify>
1. Open index.html in browser -- test-room-a renders with colored background and visible hotspot outlines
2. Hover over different hotspots -- cursor changes appearance (different cursor icon per type)
3. Click the exit hotspot -- scene fades out, test-room-b fades in with different background color
4. Click exit in test-room-b -- returns to test-room-a
5. Click the "look" hotspot -- text appears at bottom of screen, then fades after 3 seconds
6. No console errors throughout
  </verify>
  <done>Two test scenes are navigable via exit hotspots with smooth fade transitions. Cursor visually changes on hotspot hover. Look hotspots display text feedback. Talk/pickup hotspots gracefully degrade when their systems are not yet loaded.</done>
</task>

</tasks>

<verification>
1. Open index.html in a browser
2. Confirm: colored background scene fills viewport, hotspot outlines visible
3. Hover hotspots: cursor changes per type (look/exit/talk show different cursors)
4. Click exit hotspot: smooth fade transition to second scene
5. Click exit in second scene: returns to first scene
6. Click look hotspot: text appears bottom-center, fades after 3s
7. Click talk hotspot: graceful fallback message (dialogue not yet built)
8. Browser console: no errors
9. Game.currentScene reflects the visible scene
10. Game.flags and Game.inventory are accessible objects
</verification>

<success_criteria>
- Scene container fills viewport with placeholder background color
- Hotspots render as positioned elements within the scene
- Cursor appearance changes on hotspot hover (distinct per type)
- Exit hotspot click triggers fade-out/fade-in transition to target scene
- Look hotspot click shows text feedback that auto-fades
- Talk and pickup hotspot clicks degrade gracefully
- Game state object tracks currentScene, inventory, flags
- No console errors on any interaction
</success_criteria>

<output>
After completion, create `.planning/phases/01-engine-systems/01-01-SUMMARY.md`
</output>
